//
// Created by c1533 on 2022/9/16.
//
/**最小生成树
 * 生成树：对连通的无向图，找到一个包含所有顶点的子图，且该子图连通，边的数量比顶点数少一，一个图可以有多个生成树
 * 最小生成树：对一个带权连通无向图G=(V,E)，生成树不同，每棵树的权也可能不同，设R为G的所有生成树的集合，若T为R中边的权值最小的生成树，则G为最小生成树(MST)
 * 最小生成树也不唯一，不同起点出发可得到同一最小生成树
 * Prim算法（手算即可）
 *      从某顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，知到所有顶点都纳入为止
 *      适合边稠密图
 * Kruskal算法
 *      每次选择一条权值最小的边，使这条边的两头连通(原本连通的不选)直到所有结点都连通
 *      适合边稀疏图
 * */
/**Prim算法实现
 * 创建两个数组，一个标记结点是否已加入树，一个标记各结点加入树的最低代价
 * 将v0加入数组，则v0对应数据为1，其它为0；第二个数组中写入该顶点到其余顶点距离，如v0=0，v1=6，v3=1……不邻接则为∞
 * 第一轮：循环遍历所有结点，找到lowCast最小的且暂未加入树的顶点，再次循环遍历，更新没有加入的各个顶点的lowCast值
 * 第n轮：循环遍历未加入树的结点，找到lowCast最低的
 * 从V0开始，总共需要n-1轮处理，每一轮处理都找lowCast最低且未加入树的，之后更新未加入树的lowCast值
 * 每一轮时间复杂度O(2n)，总时间复杂度O(n^2)即O(|V|^2)
 * */
/**Kruskal算法实现
 * 初始预处理：将各条边按权值排序(从小到大)
 * 列表：weight Vertex1 Vertex2，分别表示权值，顶点1，顶点2
 * 第一轮：检查第一条边的两个顶点是否属于同一个集合(连通)——并查集
 *              不连通的连接起来，使之变成同一个集合
 * 第n轮：同上，如果某两个顶点属于同一个集合，跳过
 * 图G有e条边，所以执行e轮，每轮判断两个顶点是否属于同一集合，需要O(log2^e)，总时间复杂度O(elog2^e)
 * */






